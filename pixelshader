varying vec2 texture_coordinate;
uniform sampler2D data;
uniform sampler2D grass_texture;
uniform sampler2D city_texture;
uniform sampler2D forest_texture;
uniform sampler2D rock_texture;
uniform sampler2D street_texture;
uniform sampler2D water_texture;

//lets read this additional variables from the CPU (ram)
uniform float t,px,py,zoom;														
uniform float ROCK,FOREST,CITY,WATER,GRASS,STREET;								//constants we need to work with
uniform int worldsize;

float randgen(float x)
{ 
	float a=16807.0; //good value
	float m=pow(2.0,31.0)-1; 											//value-area (32 bit)
	int its=3; 															//iterations
	int n=0;
	while(n<its)
	{
		x=mod((a*x),m);													//linear congruential generator	
		n++;
	}
	return float(x/pow(2.0,31.0));
}
float offset=0;
float randwt() 															//without time, because of its deterministic character, it is like if a HUGE amount
{ 																		//of data is saved on the GPU, which isn't, its just recalculated all the time
	offset++;															//with this random generator we can implement procedural textures
	return randgen(1000*texture_coordinate.x+1000*texture_coordinate.y+offset); 
}
float rand() 															//random with time, maybe no usage
{ 
	offset++;
	return randgen(t*1000+1000*texture_coordinate.x+1000*texture_coordinate.y+offset);
}
void main()
{ 
	float step=1.0/((float)worldsize);
	float state=texture2D(data, texture_coordinate).r;
	float lastchange=1.0/texture2D(data, texture_coordinate).g-0.1;
	float height=(1.0/texture2D(data, texture_coordinate).b-0.1)/10.0;
	float wateramount=1.0/texture2D(data, texture_coordinate).a-0.1;
	vec4 color=vec4(0.4+height/1.5,0.6+height/1.5,0.1+height/1.5+wateramount/5.0,1);	//calculate color for vis
	if(abs(state-GRASS)<0.01)			//WHAT THE HELL GPU I wanted FLOAT accuracy!!!!
	{
		gl_FragColor=texture2D(grass_texture, texture_coordinate*worldsize);
	}
	if(abs(state-ROCK)<0.01)
	{
		gl_FragColor=texture2D(rock_texture, texture_coordinate*worldsize);
	}
	if(abs(state-CITY)<0.01)
	{
		gl_FragColor=texture2D(city_texture, texture_coordinate*worldsize);
	}
	if(abs(state-FOREST)<0.01)
	{
		gl_FragColor=texture2D(forest_texture, texture_coordinate*worldsize);
	}
	if(abs(state-STREET)<0.01)
	{
		gl_FragColor=texture2D(street_texture, texture_coordinate*worldsize);
	}
	if(abs(state-WATER)<0.01)
	{
		vec2 tc=texture_coordinate;
		float state_r=texture2D(data, vec2(texture_coordinate.x+step,texture_coordinate.y)).r;
		float state_l=texture2D(data, vec2(texture_coordinate.x-step,texture_coordinate.y)).r;
		float state_t=texture2D(data, vec2(texture_coordinate.x,texture_coordinate.y+step)).r;
		float state_d=texture2D(data, vec2(texture_coordinate.x,texture_coordinate.y-step)).r;
		float state_rd=texture2D(data, vec2(texture_coordinate.x+step,texture_coordinate.y-step)).r;
		float state_ld=texture2D(data, vec2(texture_coordinate.x-step,texture_coordinate.y-step)).r;
		float state_rt=texture2D(data, vec2(texture_coordinate.x+step,texture_coordinate.y+step)).r;
		float state_lt=texture2D(data, vec2(texture_coordinate.x-step,texture_coordinate.y+step)).r;
		float distance=999;
		if(abs(state_r-GRASS)<0.01)
		{
			distance=min(distance, (tc.x/(float)step-(int)(tc.x/(float)step)) );
		}
		if(abs(state_l-GRASS)<0.01)
		{
			distance=min(distance, (1-(tc.x/(float)step-(int)(tc.x/(float)step))) );
		}
		if(abs(state_t-GRASS)<0.01)
		{
			distance=min(distance, (tc.y/(float)step-(int)(tc.y/(float)step)) );
		}
		if(abs(state_d-GRASS)<0.01)
		{
			distance=min(distance, (1-(tc.y/(float)step-(int)(tc.y/(float)step))) );
		}
		if(abs(state_l-WATER) && abs(state_d-WATER) && abs(state_ld-GRASS)<0.01)
		{
			distance=sqrt(pow(1-(tc.x/(float)step-(int)(tc.x/(float)step)),2)+pow(1-((tc.y/(float)step-(int)(tc.y/(float)step))),2))/1.3;
		}
		if(abs(state_r-WATER) && abs(state_d-WATER) && abs(state_rd-GRASS)<0.01)
		{
			distance=sqrt(pow((tc.x/(float)step-(int)(tc.x/(float)step)),2)+pow(1-((tc.y/(float)step-(int)(tc.y/(float)step))),2))/1.3;
		}
		if(abs(state_r-WATER) && abs(state_t-WATER) && abs(state_rt-GRASS)<0.01)
		{
			distance=sqrt(pow((tc.x/(float)step-(int)(tc.x/(float)step)),2)+pow(((tc.y/(float)step-(int)(tc.y/(float)step))),2))/1.3;
		}
		if(abs(state_l-WATER) && abs(state_t-WATER) && abs(state_lt-GRASS)<0.01)
		{
			distance=sqrt(pow(1-(tc.x/(float)step-(int)(tc.x/(float)step)),2)+pow(((tc.y/(float)step-(int)(tc.y/(float)step))),2))/1.3;
		}
		if(distance==999)
		gl_FragColor=texture2D(water_texture, texture_coordinate*worldsize);
		else
		gl_FragColor=(1-distance)*texture2D(water_texture, texture_coordinate*worldsize)+distance*texture2D(grass_texture, texture_coordinate*worldsize);
	}
	gl_FragColor*=color;
	if(abs(state-WATER)<0.01)											//water shader
    {
		gl_FragColor+=0.01*sin(texture_coordinate.x*worldsize+t)*cos(texture_coordinate.y*worldsize+t);
    }
    if(abs(state-WATER)<0.01 && lastchange<4)							//it became water not long ago, so make noise/shore
    {
		gl_FragColor+=0.05*rand();
    }
	//gl_FragColor=texture2D(data, texture_coordinate);					//debug view if you want :D
}

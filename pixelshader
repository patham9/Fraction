varying vec2 texture_coordinate;
uniform sampler2D texture;

//lets read this data from the CPU so that we can create nice procedural textures for example
uniform int state;														//cell state and automat time
uniform int i;
uniform int j;															//coordinates of the cell and time
uniform int lastchange;													//steps since last change
uniform float t;														
uniform float height;													//height										
uniform float wateramount;												//ground water
uniform int ROCK,FOREST,CITY,WATER,GRASS;								//constants we need to work with

float randgen(float x)
{ 
	float a=16807.0; //good value
	float m=pow(2.0,31.0)-1; 											//value-area (32 bit)
	int its=3; 															//iterations
	int n=0;
	while(n<its)
	{
		x=mod((a*x),m);													//linear congruential generator	
		n++;
	}
	return float(x/pow(2.0,31.0));
}
float offset=0;
float randwt() 															//without time, because of its deterministic character, it is like if a HUGE amount
{ 																		//of data is saved on the GPU, which isn't, its just recalculated all the time
	offset++;															//with this random generator we can implement procedural textures
	return randgen(1000*texture_coordinate.x+1000*texture_coordinate.y+offset); 
}
float rand() 															//random with time, maybe no usage
{ 
	offset++;
	return randgen(sin(t)*1000+1000*texture_coordinate.x+1000*texture_coordinate.y+offset);
}
float pixel_positionX()
{
	return i+(1-texture_coordinate.x);
}
float pixel_positionY()
{
	return j+(1-texture_coordinate.y);
}

void main()
{
    //sample the texture and multiply it with the openGL color
    gl_FragColor = gl_Color*texture2D(texture, texture_coordinate);
    if(state==WATER)
    {
		gl_FragColor+=0.01*sin(pixel_positionX()+t)*cos(pixel_positionY()+t);
    }
    if(state==WATER && lastchange<3) //it became water not long ago, so make noise
    {
		gl_FragColor+=0.1*rand();
    }
}

varying vec2 texture_coordinate;
uniform sampler2D data;
uniform sampler2D grass_texture;
uniform sampler2D city_texture;
uniform sampler2D forest_texture;
uniform sampler2D rock_texture;
uniform sampler2D water_texture;

//lets read this additional variables from the CPU (ram)
uniform float t;														
uniform float ROCK,FOREST,CITY,WATER,GRASS;								//constants we need to work with
uniform int worldsize;

float randgen(float x)
{ 
	float a=16807.0; //good value
	float m=pow(2.0,31.0)-1; 											//value-area (32 bit)
	int its=3; 															//iterations
	int n=0;
	while(n<its)
	{
		x=mod((a*x),m);													//linear congruential generator	
		n++;
	}
	return float(x/pow(2.0,31.0));
}
float offset=0;
float randwt() 															//without time, because of its deterministic character, it is like if a HUGE amount
{ 																		//of data is saved on the GPU, which isn't, its just recalculated all the time
	offset++;															//with this random generator we can implement procedural textures
	return randgen(1000*texture_coordinate.x+1000*texture_coordinate.y+offset); 
}
float rand() 															//random with time, maybe no usage
{ 
	offset++;
	return randgen(t*1000+1000*texture_coordinate.x+1000*texture_coordinate.y+offset);
}
void main()
{ 
	float state=texture2D(data, texture_coordinate).r;
	float lastchange=1.0/texture2D(data, texture_coordinate).g-0.1;
	float height=1.0/texture2D(data, texture_coordinate).b-0.1;
	float wateramount=1.0/texture2D(data, texture_coordinate).a-0.1;
	vec4 color=vec4(0.3+height/1.5,0.5+height/1.5,0.0+height/1.5+wateramount/5.0,1);	//calculate color for vis
	if(abs(state-GRASS)<0.01)			//WHAT THE HELL GPU I wanted FLOAT accuracy!!!!
	{
		gl_FragColor=texture2D(grass_texture, texture_coordinate*worldsize);
	}
	if(abs(state-ROCK)<0.01)
	{
		gl_FragColor=texture2D(rock_texture, texture_coordinate*worldsize);
	}
	if(abs(state-CITY)<0.01)
	{
		gl_FragColor=texture2D(city_texture, texture_coordinate*worldsize);
	}
	if(abs(state-FOREST)<0.01)
	{
		gl_FragColor=texture2D(forest_texture, texture_coordinate*worldsize);
	}
	if(abs(state-WATER)<0.01)
	{
		gl_FragColor=texture2D(water_texture, texture_coordinate*worldsize);
	}
	gl_FragColor*=color;
	if(abs(state-WATER)<0.01)											//water shader
    {
		gl_FragColor+=0.01*sin(texture_coordinate.x*worldsize+t)*cos(texture_coordinate.y*worldsize+t);
    }
    if(abs(state-WATER)<0.01 && lastchange<4)							//it became water not long ago, so make noise/shore
    {
		gl_FragColor+=0.1*rand();
    }
	//gl_FragColor=texture2D(data, texture_coordinate);					//debug view if you want :D
}
